# Chapter 2 아키텍처 사고
- 아키텍트는 개발자와 다른 관점에서 주변을 바라봄
  - 단순하게 '아키텍처를 생각하는 것' 이상으로 심오함

- 아키텍트의 사고방식 네가지
  - 아키텍처와 설계의 차이를 이해하고 아키텍처 작업을 진행하려면 개발팀과 어떻게 협력해야 할지 아는 것
  - 어느 정도 기술 깊이를 유지하면서, 폭넓은 기술 지식을 확보하는 것
    - 다른 사람이 보지 못하는 해결책과 가능성을 떠올릴 수 있음
  - 다양한 솔루션과 기술 간의 트레이드오프를 이해하고, 분석하고, 조율하는 것
  - 비즈니스 동인(모델)의 중요성을 이해하고 그것을 아키텍처 관심사로 해석할 줄 아는 것

## 2.1 아키텍처 대 설계
- 아키텍처와 설계의 차이점은 모호한 경우가 많음
- 아키텍트처럼 사고한다는 것은 비즈니스와 기술 문제를 해결하기 위해 아키텍처와 설계의 차이점을 알고 이 둘을 긴밀하게 통합할 솔루션을 모색하는 것

- **`전통적인 아키텍트와 개발자 책임 비교`**
  - 아키텍트는  비즈니스 요구사항을 분석해서 아키텍처 특성을 도출/정의하고 어떤 아키텍처 패턴과 스타일이 해당 문제 영역에 가장 알맞는지 선택하여 각종 컴포넌트(시스템 구성요소)를 만들고, 이를 수행하여 아티팩트를 만들어 개발팀에 전달
  - 개발팀은 각 컴포넌트 클래스 다이어그램을 그린 뒤 UI 화면을 만들고 소스 코드를 개발/테스트 수행

  <img width="520" height="307" alt="CleanShot 2025-08-17 at 18 59 56" src="https://github.com/user-attachments/assets/cc8a919a-dce4-435a-9c15-3f8fc2836fb6" />

- 이런 전통적인 역할 모델에는 문제점이 많음
  - 아키텍트와 개발자가 나누는 가상의 물리적 장벽을 통과하는 단방향 화살표 구조(모든 문제의 원인)
  - 아키텍트가 내린 결정이 개발팀에 쓸모 없는 경우가 있는데도, 개발팀이 아키텍처를 변경하기로 한 결정이 아키텍트에게 전달될 수 없음
  - 즉, 아키텍트가 개발팀과 완전히 단절되어 소통이 원활하게 되지 않음

- 따라서, 제대로 된 아키텍처를 만들려면 **`아키텍트와 개발자 두 팀이 양방향으로 소통하는 관계를 정립해야 함`**
  - 아키텍트, 개발자 모두 활발히 소통하면서 아키텍트는 팀 내 개발를 멘토링/코치하는 역할도 수행할 수 있도록 가상의 동일한 팀에 소속되어야 함
  
  <img width="555" height="364" alt="CleanShot 2025-08-17 at 19 03 54" src="https://github.com/user-attachments/assets/eb5fc1b7-bf58-46d9-9ee3-e9fdff0dad2f" />

- 특히, 폭포수 모델과 달리 요즘 시스템 아키텍트는 매 단계, 이터레이션마다 끊임없이 변화하고 발전하기 때문에 아키텍트와 개발팀이 똘똘 뭉쳐야 함
- **즉, 아키텍처와 설계의 경계는 따로 없음. 아키텍처와 설계 모두 소프트웨어 프로젝트 생명주기의 일부로서 항상 서로 동기화되어야 성공할 수 있음**

## 2.2 기술 폭
- 기술 세부의 범위 또한 개발자와 아키텍트가 다름
  - 개발자 : 업무를 진행하기 위해 기술 깊이를 확보해야 함
  - 아키텍트 : 아키텍트 답게 사고하고 아키텍처 시각을 유지하기 위해 상당한 기술 폭을 갖춰야 함

- `지식의 분류`
  - 내가 알고 있는 것
  - 내가 모른다는 사실을 아는 것
  - 내가 모른다는 사실조차 모르는 것

  <img width="420" height="336" alt="CleanShot 2025-08-17 at 19 07 50" src="https://github.com/user-attachments/assets/01f997c4-be22-406f-8ed3-73753e8cf66f" />

- `내가 알고 있는 것`
  - 일상 업무 수행에 사용하는 기술, 프레임워크, 언어, 도구

- `내가 모른다는 사실을 아는 것`
  - 한 번 들어 봤거나 얕은 지식은 갖고 있지만 실무 경험은 전무한 기술

- `내가 모른다는 사실조차 모르는 것`
  - 기술자가 해결하려는 문제에 완벽한 정답임에도 불구, 그 존재조차 알지 못하는 다수의 기술, 도구, 프레임워크, 언어
  - 지식 피라미드에서 가장 많은 부분을 차지

- 초심자 시절에는 이 피라미드 꼭대기를 점점 넓혀 경험과 전문성을 쌓는 데 주력함
- 점점 중간 영역도 넓어지고 관련 기술과 아티팩트를 더 많이 접하면서 `내가 모른다는 사실을 아는 것` 이 점점 늘어남
- 전문적인 기술은 중요하기 때문에 `내가 알고 있는 것`은 `내가 유지해야 할 것` 이기도 함
  - 개발자라면 자기가 가진 기술적 깊이를 늘리고 유지해 나아가야함(전문성) 
  
  <img width="459" height="328" alt="CleanShot 2025-08-17 at 19 12 48" src="https://github.com/user-attachments/assets/bcb7cb99-f76d-4a83-9e66-25d7953e4301" />

- 하지만, 개발자에서 아키텍트로 진로를 바꾸면 지식의 성격이 달라짐
  - 아키텍트의 가치는 대부분 기술에 대한 폭넓은 이해와 그 기술을 사용해서 특정한 문제를 해결하는 것임
  - 즉, 한 가지 문제만 해결 가능한 한 가지 전문 지식보다는, 문제를 해결할 수 있는 여러가지 솔루션을 알고 있는게 더 중요함
  - 아키텍트에게 중요한 영역은 꼭대기와 중간으로 기술 폭은 중간 영역이 아래 영역을 얼마나 더 멀리 관통하는가임
  - 아키텍트에게는 깊이보다 폭이 더 중요. 기술적인 제약 하에 어떤 기능이 가장 알맞는지 결정해야하기 때문에 폭넓은 솔루션을 두루 꿰고 있어야함

    <img width="478" height="414" alt="CleanShot 2025-08-17 at 19 16 55" src="https://github.com/user-attachments/assets/332bc5ec-e952-43f9-b5a1-48ff4c33896a" />

- 개발자가 아키텍트로 전환하려면 관점을 바꾸어야 하는데, 많은 사람들이 이것을 어려워하고, 두 가지 역효과가 일어남
  - 다양한 분야에서 전문성을 유지하려고 하나, 어느 하나도 성공하지 못한 채 그러는 도중 지쳐버림
  - 김빠진 전문성이 나타남, 자신의 낡은 정보가 아직도 첨단을 달리고 있는 것처럼 그릇된 인식에 사로잡히게 됨

- 깊이와 폭 사이에서 지식 포트폴리오의 균형을 맞추는 일은 모든 개발자가 커리어 내내 고민해야 할 문제임

#### 꽁꽁 언 원시인 안티 패턴
- 과거에 나쁜 결정이나 예기치 못한 사고로 인해 현재 상황에 적절한 아키텍처임에도 극도의 경계심을 가져 올바르지 못한 결정을 하지 못하는 사고 방식

## 2.3 트레이드오프 분석
- 아키텍트처럼 생각하는 것은 기술 여부와 상관없이 **`모든 솔루션의 트레이드오프를 분석하여 최선의 솔루션을 결정하는 것`** 임
- 아키텍처는 모든게 다 트레이드 오프임. 따라서, 상황에 따라 올바른 아키텍처가 다른 경우가 많음
  - 아키텍처는 구글링해도 안되는 것이다
  - 아키텍처는 정답도, 오답도 없다. 오직 트레이드오프만 있을 뿐

- 아키텍처는 배포 환경, 비즈니스 모델, 회사 문화, 예산, 기간, 개발자 스킬 세트 등 여러 요소들이 영향을 미침
- 아키텍처가 어려운 이유는 이러한 요소들이 저마다 다른 환경, 상황, 문제를 안고 있어서 어려움

#### 예시 : 경매 참가자들이 원하는 물품에 입찰을 하는 경매 시스템
  
<img width="534" height="275" alt="CleanShot 2025-08-17 at 21 11 42" src="https://github.com/user-attachments/assets/7ade0146-a4cf-4c24-9bf5-cfbabc3b9db0" />

  - 해당 작업은 큐를 사용한 점대점 메시징 모델도 가능하고 토픽을 사용한 메시지 발행/구독 모델도 가능함
  - 따라서, 아키텍처적으로 사고하려면 각 방안의 트레이드오프를 분석하고 주어진 상황에서 가장 나은 선택을 해야함 

- **`토픽을 사용한 메시지 발행/구독 모델`** vs **`큐를 사용한 점대점 메시징 모델`** 트레이드 오프 분석

- **`토픽을 사용한 메시지 발행/구독 모델`**

  <img width="566" height="290" alt="CleanShot 2025-08-17 at 21 14 16" src="https://github.com/user-attachments/assets/7d1d5fe3-cfc5-43eb-aaf8-2384d3f2f4a6" />

  - 아키텍처 확장성(신장성) 뛰어남
  - producer 서비스는 한 토픽에 한 번만 연결하면 됨
  - 새로운 서비스가 도입되더라도 기존 서비스는 변경이 필요가 없는 구조
    - producer가 발행한 정보를 어떤 서비스가 사용하는지 모름 
  - 덜 커플링되는 구조

- **`큐를 사용한 점대점 메시징 모델`**

  <img width="560" height="319" alt="CleanShot 2025-08-17 at 21 14 50" src="https://github.com/user-attachments/assets/af9a6439-2781-474e-af32-2d85da5680ed" />

  - producer 서비스는 각각의 큐에 접속해야 함
  - 새로운 서비스가 도입되려면 producer 서비스 변경 불가피(큐를 추가하고 연결해주어야 함)
    - producer는 발행한 정보를 어떤 서비스가 사용하는지 알아야 함
  - 상대적으로 커플링이 더 되는 구조

- 이렇게만 보면 메세지 발행/구독 모델에 따라 토픽을 사용하는 것이 최적의 선택으로 보임
  - 프로그래머는 장점은 잘 알지만 트레이드오프는 잘 모르는 경우가 많음. 하지만, **`아키텍트는 둘 다 잘 알아야 한다`**

- 토픽을 사용한 메시지 발행/구독 모델 **`단점 분석`**
  - 누구나 입찰 데이터에 엑세스 할 수 있으므로 보안 문제가 불거질 수 있음
  - 데이터를 수신한 서비스는 모드 동일한 데이터 세트를 받아야 함
  - 메세지 개수를 모니터링할 수 없음
  - 자동 확장 기능이 지원되지 않음

- 큐를 사용한 점대점 메시징 모델 **`단점 분석`**
  - 지정된 컨슈머만 액세스 가능함
  - 필요한 데이터만 받을 수 있음
  - 큐를 따로 모니터링 할 수 있음
  - 개별적으로 로드밸런싱 로직을 적용할 수 있기 때문에 상호 독립적인 자동 확장이 가능함
    - AMQP 구조의 기술적인 특성

- 이렇게 트레이드오프(장단점)를 분석했을 때 어느 쪽이 더 나은가는 요구 사항(환경)에 따라 다르게 됨

  <img width="557" height="158" alt="CleanShot 2025-08-17 at 21 22 56" src="https://github.com/user-attachments/assets/f2e30e1e-b8b0-4232-ab69-9e6c7ee80465" />

- 결론은 소프트웨어는 만사가 트레이드오프를 갖고 있음. 여러 솔루션 중 올바른 아키텍처는 언제나 비즈니스, 환경 등 다양한 요소에 좌우됨

## 2.4 비즈니스 동인의 이해
- 아키텍처 사고는 성공적인 시스템 구축에 필요한 비즈니스 동인을 이해하고 요구사항을 (확장성, 성능 가용성 등의) 아키텍처 특성으로 해석하는 것
- 따라서, 아키텍트는 어느 정도의 비즈니스 도메인 지식을 갖고서 비즈니스 핵심 인사들과 원만하고 협력적인 관계를 유지해야 함

## 2.5 아키텍처와 코딩 실무 간 균형 맞추기
- 코딩 실무와 소프트웨어 아키텍처의 균형을 맞추는 것도 아키텍트가 극복해야 할 어려운 일 중 하나임
  - 모든 아키텍트는 코딩을 하면서 어느 정도의 기술 깊이는 유지해야 함

- 코딩 실무와 아키텍처의 균형을 맞추기 위해서는 `병목 트랩`에 빠지면 안됨
  - 병목 트랩은 아키텍트가 프로젝트의 크리티컬 패스(임계 경로, 최장 경로)에 있는 코드의 소유권을 가지고 있는 경우 발생함
  - 아키텍트는 풀타임 개발자가 아니므로, 개발자 역할과 아키텍트 역할의 균형을 잘 맞춰야 함

- 아키텍트가 개발팀과 함께 코드를 개발할 수 없는 상황에서 코딩 실무 능력을 잃지 않고 일정 수준의 기술 깊이를 유지하는 방법
  - **`개념 증명(Proof Of Concept)을 자주 해보는 것`**
    - POC는 아키텍트가 소스코드를 직접 작성해보면서 구현 상세를 생각하게 되므로 아키텍처 결정을 검증하는데 유용
    - POC 작업을 할 때에는 가능한 한 프로덕션 수준의 고품질 코드를 작성하는 것이 좋음
      - 아키텍트가 쓰고 버리려고 작성한 POC 코드가 소스 코드 리포지터리에 커밋되면 외려 이것이 레퍼런스 아키텍처가 되거나 좋은 샘플이 되는 경우가 많음
      - 아키텍트는 프로덕션 품질의 POC 코드를 작성해보면서 나쁜 코딩 습관이 점점 더 손에 배기 전에 잘 짜인 양질의 코드를 작성하는 습관을 들이게 됨

  - 개발팀이 아주 중요한 유저 스토리 작업을 할 수 있도록 기술 부채 스토리나 아키텍처 스토리에 전념하는 것
    - 커맨드라인 도구나 분석기를 만들어 개발팀의 일상 업무를 간소화, 자동화하는 것도 좋음
    - 아키텍처의 컴플라이언스 보장을 자동화하기 위해 피트니스 함수를 사용

- 자주 코드 리뷰를 하기
  - 직접 코딩하지는 않아도 소스 코드에 관여하는 활동을 통해 컴플라인언스를 보장하고, 팀원을 멘토링할 수 있음
        
