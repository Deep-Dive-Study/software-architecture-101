아키텍트는 소프트웨어 솔루션을 설계할 때 많은 부분을 고려해야 한다.

아키텍트는 개발팀과 함께 도메인 또는 비즈니스 요구사항을 정의할 수 있지만, 주로 소프트웨어로 처리할 일 중 도메인 기능과 직접적인 관련이 없느 모든 것들, 즉 아키텍처 특성을 정의, 발견, 분석하는 일을 수행한다.

- 아키텍처 특성
    - 비도메인 설계 고려사항을 명시한다.
        - 애플리케이션으로 처리할 일은 구체적인 요구사항으로 정리한다.
    - 설계의 구조적 측면에 영향을 미친다.
        - “아키텍처 특성은 어떤 특별한 구조적 요소를 고려해야 하는가”같은 설계 고려 사항이 있다.
    - 애플리케이션 성공에 중요하다.
        - 아키텍처 특성을 한 가지만 늘려도 설계 복잡도는 가중되므로 가급적 특성을 적게 선정한다.
        - 아키텍처 특성을 명시적 특성과 암묵적 특성으로 분류한다.

# 1. 아키텍처 특성 (일부) 목록

아키텍처 특성은 모듈성 같은 저수준 코드의 특성부터 확장성, 탄력성 같은 복잡한 운영 문제까지 소프트웨어 시스템의 넓은 범위에 고루 존재한다.

규모와 범위는 방대하지만 아키텍트는 보통 아키텍처 특성을 넓은 범주로 나눈다.

## 1) 운영 아키텍처 특성

| 용어 (Term) | 정의 (Definition) |
| --- | --- |
| 가용성 (Availability) | 시스템이 얼마나 오랫동안 사용 가능해야 하나? (24/7이면 장애 발생 시 시스템을 신속하게 재가동시키는 절차가 준비되어야 함) |
| 연속성 (Continuity) | 재해 복구 능력 |
| 성능 (Performance) | 스트레스 테스트, 피크 분석, 기능 사용 빈도 분석, 평균 용량, 응답 시간. 이 정도 성능이면 됐다 싶으면 직접 돌려봐야 하는데 그 기간만 대략 수 개월 소요된다. |
| 복구성 (Recoverability) | 비즈니스 연속성 요구사항(예를 들어, 장애 발생 시 얼마나 신속하게 시스템을 재가동시켜야 하나?), 백업 전략과 하드웨어 대용량 요건에 영향을 미친다. |
| 신뢰성/안전성 (Reliability/Safety) | 시스템에 페일 세이프(fail-safe)가 필요한가?, 또 페일 세이프가 시스템 가동에 필수인가? 시스템 실패 시 회사에 치명적 손실이 발생하는가? |
| 견고성 (Robustness) | 프로그램 실행 중 인터럽트 적절 감검, 정전, 하드웨어 실패 등 여러 경계 조건을 감당하는 능력 |
| 확장성 (Scalability) | 유지 수, 요청 수가 늘어나도 시스템이 그에 맞는 성능을 발휘하는 능력 |

## 2) 구조 아키텍처 특성

| **용어 (영어)** | **정의** |
| --- | --- |
| 설정성 (configurability) | 최종 유지자(end user)가 (쓰기 편한 인터페이스를 통해) 소프트웨어 설정을 쉽게 바꿀 수 있는가? |
| 신장성 (extensibility) | 새로운 기능을 삽입하는 일의 중요성(또는 용이성). |
| 설치성 (installability) | 필요한 모든 플랫폼에 시스템을 얼마나 손쉽게 설치할 수 있나? |
| 활용성 / 재사용성 (reusability) | 공통 컴포넌트를 여러 제품에서 활용할 수 있나? |
| 지역성 (locality) | 데이터를 입력/조회하는 화면에서 다국어가 지원되는가? 리포트·장표에서 멀티바이트 문자 및 측정, 화면 단위 등의 요구사항을 만족하는가? |
| 유지보수성 (maintainability) | 시스템을 얼마나 쉽게 변경/개선할 수 있나? |
| 이식성 (portability) | 하나 이상의 플랫폼에서 시스템을 실행할 수 있나? (예: 동일한 프런트엔드를 SAP DB와 오라클 DB에서 모두 실행할 수 있는가?) |
| 지원성 (supportability) | 애플리케이션은 어느 정도의 기술 지원을 필요로 하는가? 시스템 오류를 디버깅하려면 로그 및 기타 기능이 어느 수준으로 뒷받침되어야 하는가? |
| 업그레이드성 (upgradeability) | 애플리케이션/솔루션의 구(舊) 버전을 새 버전으로 쉽고 빠르게 업그레이드할 수 있는가? |

## 3) 아키텍처 공통 특성

| **용어 (영어)** | **정의** |
| --- | --- |
| 접근성 (accessibility) | 색맹, 청각 장애인 등 모든 유저가 접근하는 데 불편함이 없는가? |
| 보관성 (archivability) | 데이터를 따로 아카이빙(archiving)해야 하나, 아니면 일정 시간 경과 후 삭제해야 하나? (예: 고객 계정을 3개월 후 삭제하거나 미사용 계정으로 표시하는 등. 추후 고객이 다시 접속할 수 있어 보조 DB에 아카이빙할 수 있음.) |
| 인증 (authentication) | 유저가 본인임을 증명하기 위해 필요한 보안 요구사항 |
| 인가 (authorization) | (유스케이스, 서비스 시스템, 웹페이지, 비즈니스 규칙, 필드 레벨 등에서) 유저가 애플리케이션에서 정해진 기능만 사용할 수 있도록 강제하는 보안 요구사항 |
| 합법성 (legal) | 시스템 운영상 법적 제약 조건이 있는가? (데이터 보호, 서비스 보존, GDPR 등). 회사는 어떤 권리를 보유·유보해야 하는가? 애플리케이션을 개발/배포하는 방법에도 별도 법적 규정이 있는가? |
| 프라이버시 (privacy) | 회사 내부 임직원의 트랜잭션이 외부에 드러나지 않도록 하는 기능(예: 암호화, 트랜잭션 로그 접근 제어 등)이 요구되는가? |
| 보안 (security) | 데이터를 암호화한 후 데이터베이스에 보관해야 하는가? 내부 시스템 간 네트워크 통신도 암호화해야 하는가? 권한·접근 제어를 위해 어떤 인증 방식이 필요한가? |
| 사용성/성취성 (usability / achievability) | 유저가 애플리케이션/솔루션을 사용해 목표를 달성하려면 필요한 교육·훈련 수준과 사용성 요구사항을 어떻게 충족할 것인가? 이는 다른 아키텍처 이슈만큼 중요하다. |

아키텍처 특성은 어떻게 나열해도 불완전한 목록이 될 수 밖에 없다.

소프트웨어마다 고유한 팩터를 바탕으로 중요한 아키텍처 특성이 도출될 수도 있다.

이 세상에 완벽한 표준 목록은 없다. 국체 표준 기구(ISO)가 발표한 기능별 목록만 보아도 지금까지 우리가 나열한 특성들과 중복되거나 카테고리 목록이 불완전한 편이다.

| **용어 (영어)** | **정의** |
| --- | --- |
| 성능 효율 (performance efficiency) | 아려진 조건에서 리소스 양에 비해 나타나는 성능 측정값.

시간 특징, 리소스 사용, 능력 등 |
| 호환성 (compatibility) | 제품·시스템·컴포넌트가 다른 제품·시스템·컴포넌트와 정보를 교환하거나 동일한 하드웨어/소프트웨어 환경을 공유하면서 필요한 기능을 수행할 수 있는 정도  |
| 사용성 (usability) | 사용자가 시스템을 목표에 맞게 효과적·효율적·만족스럽게 사용할 수 있는 정도.  |
| 신뢰성 (reliability) | 주어진 기간·조건에서 시스템이 정상적으로 기능하는 정도. |
| 보안 (security) | 시스템이 데이터와 기능을 보호하는 정도. |
| 유지보수성 (maintainability) | 개발자가 소프트웨어를 효율적으로 수정·개선하고 변화하는 요구에 적응시킬 수 있는 능력 |
| 이식성 (portability) | 소프트웨어·시스템·컴포넌트를 다른 하드웨어·소프트웨어·운영 환경으로 옮기거나 적응시킬 수 있는 정도 |
| 기능 적합성 (functional suitability) | 제품/시스템이 주어진 조건에서 명시·암묵적 요구사항을 충족하는 정도 |

# 2. 트레이드오프 및 나쁜 것 중에서 제일 나은 아키텍처

아키텍트가 설계하기로 결정한 아키텍처 특성 하나하나가 전체 설계를 복잡하게 만들 가능성을 품고있다.

아키텍처 특성을 너무 욕심내면 모든 비즈니스 문제를 해결하려고 시도하는 일반적인 솔루션이 되어버린다. 이런 아키텍처는 설계하기가 까다롭기에 실현 가능성이 낮다.

아키텍트는 가능한 한 아키텍처 설계를 꾸준히 조금씩 반복해보는게 좋다. 반복의 가치는 애자일 소프트웨어 개발에서도 가장 중요한 교훈 중 하나로, 아키텍처뿐만 아니라 모든 레벨의 소프트웨어 개발에도 적용된다.ㅌ
