# Chapter 03 모듈성
- 소프트웨어 아키텍처의 대부분의 개념들은 모듈성의 이로움을 찬양하는데 사용되지만, 정작 모듈성을 어떻게 달성할지에 대해서는 별 다른 얘기가 없음
- 또한, 모듈성은 제대로 정의하기 쉽지 않은 개념임

- 모듈성은 **`일종의 구성 원리`**
  - 모듈성을 잘 유지하는 건 암묵적 아키텍처 특성이라고 정의한 것의 좋은 예
  - Ex) 모듈이 확실히 구분되고 모듈 간 통신이 잘 되어야 한다고 공식적으로 아키텍트에게 요구하는 프로젝트는 드물지만, 코드베이스를 잘 발전시켜 나가려면 암묵적으로 질서와 일관성이 필요 

## 3.1 정의
- **`복잡한 구조를 만드는 데 쓰이는 각각의 표준화한 부품이나 독립적인 단위`**
  - 객체 지향 언어의 클래스나 함수형 언어의 함수가 될 만한 **`서로 연관된 코드를 논리적으로 묶음`**

- 아키텍트는 개발자가 코드를 어떻게 패키징하는지 알아야 함
  - 아키텍처에 영향을 중요한 영향을 미치기 때문 
  - 여러 패키지가 서로 단단히 커플링되어 있으면 그 중 하나를 다른 작업에 재사용하기가 아주 어려워짐

- 프로그램 언어에서 제공하는 클래스나 함수처럼 묶어놓은 덩어리는 논리적인 구분에 의한 모듈성임. 물리적인 분리와 다른 개념으로 바라봐야 함

## 3.2 모듈성 측정
- 모듈성을 이해하는데 도움이 될만한 세 가지 핵심 개념
  - **`응집`**
    - **`한 모듈의 파트가 동일한 모듈 안에 얼마나 포함되어 있는지, 모듈을 구성하는 파트가 서로 얼마나 연관되어 있는가`** 
  - **`커플링`**
    - **`모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미`**
  - **`커네이선스`**
    - **`어느 한쪽을 바꾸면 다른 쪽도 함께 바꾸어야 전체적으로 정합성이 유지되는 상태`**

### 3.2.1 응집
- **`한 모듈의 파트가 동일한 모듈 안에 얼마나 포함되어 있는 지, 모듈을 구성하는 파트가 서로 얼마나 연관되어 있는가`**
  - 이상적으로 응집된 모듈이라면 모든 파트가 함께 패키징되어 있음
  - 응집된 모듈은 나누려고 해봐야 오히려 더 커플링되고 가독성은 떨어짐

- 응집도 측정 범위 (좋은 것부터 나쁜 것 순으로 나열함)
  - `기능적 응집`
    - 모듈의 각 파트는 다른 파트와 연관되어 있고 **기능상 꼭 필요한 모든 것이 모듈에 들어있음**

  - `순차적 응집`
    - 두 모듈이, 한쪽이 데이터를 출력하면 다른 한쪽이 그것을 입력 받는 형태로 상호작용함

  - `소통적 응집`
    - 두 모듈이, 각자 정보에 따라 작동하고 어떤 출력을 내는 형태로 **통신 체인** 을 형성함

  - `절차적 응집`
    - 두 모듈은 정해진 순서대로 실행되어야 함

  - `일시적 응집`
    - 시점 의존성에 따라 연관됨. Ex) 시스템 시동 시점에 동시에 초기화되는 여러 작업들

  - `논리적 응집`
    - 모듈의 내부 데이터는 기능적이 아니라, 논리적으로 연관되어 있음. Ex) StringUtils 패키지

  - `동시적 응집`
    - 같은 소스 파일에 모듈 구성 요소가 들어있지만 그 외에는 아무 연관성도 없음

- 응집은 커플링보다는 덜 정확한 메트릭이므로 아키텍트 재량에 따라 측정된 모듈의 응집도는 다름

- 응집의 주관성을 전제로, 응집도를 가늠할 수 있는 메트릭을 개발됨
  - **`메서드의 응집 결여도(LCOM)`** 메트릭은 모듈의 구조적 응집도를 나타냄
    - 공유 필드를 통해 공유되지 않는 메서드의 총 개수
    - LCOM 메트릭은 아키텍처 스타일을 전환하기 위해 코드베이스를 분석하는 아키텍트에게 메우 유용
    - 어쩔 수 없이 커플링된 클래스, 처음부터 한 클래스가 아니었던 클래스를 발견하는 데 도움이 됨

  - 다만, LCOM의 메트릭이 찾아내는 것은 **`구조적 응집 결여도일 뿐, 논리적으로는 판단할 수 없음`**
    - 소프트웨어 메트릭은 거의 대부분 한두가지 중요한 결함이 있음
    - 어떻게 보다 왜가 더 중요함

### 3.2.2 커플링(결합도)
- **`모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계를 의미`**
- 메서드의 호출과 반환은 호출 그래프를 형성하므로 수학적인 분석이 가능함
- 코드베이스의 커플링은 그래프 이론에 기반한 좋은 분석 도구들이 많이 있음

- 에드워드 요던과 래리 콘스탄딘이 지은 Structured Design에 구심 커플링, 원심 커필링 등 중요 개념 대거 등장
  - `구심 커플링`
    - 코드 아티팩트(컴포넌트, 클래스, 함수 등)로 유입되는 접속 수
  - `원심 커플링`
    - 다른 코드 아티팩트로 유출되는 접속 수

- 결합도 측정 범위(좋은 것부터 나쁜 것 순으로 나열함, 정보처리기사 내용 참조)
  - `자료 결합도`
    - 모듈 간의 인터페이스가 단순 값 파라미터로만 구성

  - `스탬프 결합도`
    - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달됨

  - `제어 결합도`
    - 모듈 간의 단순 처리할 대상인 값만 전달되는 게 아니라 어떻게 처리를 해야 한다는 제어 요소가 전달됨
   
  - `외부 결합도`
    - 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조함

  - `공유 결합도`
    - 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수(공유되는 공통 데이터 영역)을 갱신하는 식으로 상호 작용함

  - `내용 결합도`
    - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 변수를 직접 참조하거나 수정(public 속성)함

### 3.2.3 추상도, 불안정도, 메인시퀀스로부터의 거리
- **`추상도`**
  - 추상 아티팩트(추상 클래스, 인터페이스 등)와 구상 아티팩트(구현체)의 비율
    - Ex) 추상화를 전혀하지 않는 애플리케이션의 경우(main() 메서드 하나에 모든 코드를 몰아넣은 경우)
    - 지나치게 추상화해서 코드가 서로 어떻게 연결되어 있는지 파악하기 힘든 경우(AbstractSingletonProxyFactoryBean 처럼)
      
    <img width="536" height="153" alt="CleanShot 2025-08-24 at 22 02 50" src="https://github.com/user-attachments/assets/e1f771fc-1166-4fe5-88c2-3799db299f07" />

- **`불안정도`**
  - 코드베이스의 변동성
    - 불안정도가 높은 코드베이스는 변경 시 커플링이 더 높아 깨지기 쉬움
    
    <img width="388" height="128" alt="CleanShot 2025-08-24 at 22 03 01" src="https://github.com/user-attachments/assets/4dd965a5-6006-4ce7-b1a1-036f2f2a8d84" />

### 3.2.4 메인 시퀀스로부터의 거리
- 불안정도와 추상도를 이용해서 메인 시퀀스로부터의 거리를 계산할 수 있음
  - 메인 시퀀스로부터의 거리는 아키텍처 구조를 평가하는 몇 가지 전체적인 메트릭 중 하나임
  
  <img width="351" height="134" alt="CleanShot 2025-08-24 at 22 11 34" src="https://github.com/user-attachments/assets/003f5e80-5ac1-4265-9abf-435f577c53df" />

  <img width="399" height="291" alt="CleanShot 2025-08-24 at 22 03 16" src="https://github.com/user-attachments/assets/038a0fa8-6571-415c-baf3-099c0879f8d5" />

  - 메인 시퀀스로부터의 거리는 추상도와 불안정도 사이의 이상적인 관계를 나타냄
  - 이상적인 선에 가까운 클래스는 서로 경쟁적인 두 메트릭의 건전한 조합이라고 볼 수 있음
  
    <img width="360" height="314" alt="CleanShot 2025-08-24 at 22 12 38" src="https://github.com/user-attachments/assets/a966aaa5-27a7-4e4d-a520-758073e06f92" />

### 3.2.5 커네이선스
- Connascence: **`어느 한쪽을 바꾸면 다른 쪽도 함께 바꾸어야 전체적으로 정합성이 유지되는 상태`**
- 밀러 페이지-존스가 1996년에 What Every Programmer Should Know About Object-Oriented Design 에서 해당 개념을 구심/원심 커플링 메트릭을 더욱 발전시킨 커네이선스 개념을 객체 지향 언어의 화두로 던짐
  - 정적 커네이선스, 동적 커네이선스로 구분

#### 정적 커네이선스
- **`소스 코드 레벨의 커플링`**
- 구심/원심 커플링을 발전시킨 개념

- `명칭 커네이선스`
  - 여러 컴포넌트의 엔티티명이 일치해야 함
  - 메서드명은 코드베이스가 커플링되는 가장 일반적이면서 바람직한 방법

- `타입 커네이선스`
  - 여러 컴포넌트의 엔티티 타입이 일치해야 함
  - 대부분의 정적 타입 언어에서 변수와 매개변수를 특정 타입으로 제한하는 일반적인 기능
  - 클로저, 클로저 스펙 등 선택적 타이핑 기능을 제공하는 동적 타입 언어도 있음

- `의미(관례) 커네이선스`
  - 여러 컴포넌트에 걸쳐 어떤 값의 의미가 일치해야 함
  - 상수 대신 숫자를 하드코딩한 코드베이스에서 흔히 발견됨

- `위치 커네이선스`
  - 여러 컴포넌트의 값의 순서가 일치해야 함
  - 정적 타이핑이 가능한 언어에서도 메서드와 함수 호출 시 전달하는 매개변수 값은 순서가 맞아야 함

- `알고리즘 커네이선스`
  - 여러 컴포넌트는 특정 알고리즘이 일치해야 함
  - 유저 인증 시 반드시 동일한 결과를 내야하는 보안 해시 알고리즘
  - 커플링이 심하다는 의미

#### 동적 커네이선스
- 런타임 호출을 분석하는 또 다른 유형의 커네이선스

- `실행 커네이선스`
  - 여러 컴포넌트의 실행 순서가 중요
  - 순서가 영향을 주는 관계

    <img width="330" height="131" alt="CleanShot 2025-08-24 at 22 17 33" src="https://github.com/user-attachments/assets/3f3e50c5-4424-47d9-91b4-b2a12496f7e4" />

- `시점 커네이선스`
  - 여러 컴포넌트의 실행 시점이 중요
  - Ex) 동시에 실행 중인 두 스레드 때문에 경합 조건이 발생하여 공동 작업의 결과에 영향을 끼치는 것

- `값 커네이선스`
  - 상호 연관된 다수의 값들을 함께 변경할 때 발생
  - 트랜잭션, 데이터베이스가 각각 분리된 시스템을 설계했는데 모든 데이터베이스에서 하나의 값을 업데이트해야 할 경우, 전체 값들을 한 번에 바꾸든지, 아무 값도 바꾸지 말든지 해야함

- `식별 커네이선스`
  - 여러 컴포넌트가 동일한 엔티티를 참조할 때 발생
  - 독립적인 두 컴포넌트가 분산 큐 같은 자료 구조를 공유해서 업데이트 하는 경우

- 런타임 호출은 호출 그래프에 비해 효과적인 분석 도구가 많지 않아 아키텍트는 동적 커네이선스를 파악하기가 쉽지 않음

#### 커네이선스 속성
- 커네이선스는 아키텍트와 개발자에게 유용한 분석 도구임
- 아래 프로퍼티를 잘 활용하면 큰 도움이 됨

- **`강도`**
  - 아키텍트는 개발자가 어떤 유형의 커네이선스를 얼마나 쉽게 리팩터링할 수 있는지에 따라 커네이선스 강도를 결정
  - 아키텍트와 개발자는 더 나은 유형의 커네이선스를 리팩터링해서 코드베이스의 커플링 특성을 개선할 수 있음
  
  <img width="395" height="343" alt="CleanShot 2025-08-24 at 02 52 19" src="https://github.com/user-attachments/assets/ecb0c357-4113-4ae4-bc66-ea821af27f3e" />

- **`지역성`**
  - `코드베이스의 모듈들이 서로 얼마나 가까이 있는가`
  - (동일한 모듈에서) 근접한 코드는 보통 (별개의 모듈 또는 코드베이스로) 더 분리된 코드보다 높은 형태의 커네이선스를 가짐
  - 모듈을 서로 떨어뜨렸을 때 커플링이 형편없는 형태의 커네이선스를 모듈을 서로 가까이 붙여 놓는 식으로 개선할 수 있음
  - 개발자는 강도와 지역성을 함께 고민해야 함
  - 동일한 모듈에서 더 강한 형태의 커네이선스가 발견된다면 그와 동일한 커네이선스가 널리 흩어져 있는 것보다는 코드 스멜이 덜함

- **`정도`**
  - 커네이선스가 미치는 영향의 규모(소수의 클래스에 영향을 미치는지 혹은 수많은 클래스에 영향을 미치는지)
  - 값이 작을수록 코드베이스 입장에서는 바람직함


#### 커네이선스를 이용해 시스템의 모듈성을 개선하는 방법 세 가지 
- 시스템을 캡슐화한 요소들로 잘게 나누어 전체 커네이선스를 최소화한다
- 캡슐화 경계를 벗어나는 나머지 커네이선스를 모조리 최소화한다
- 캡슐화 경계 내부에서 커네이선스를 최대화한다

- 전설적인 소프트웨어 아키텍처 혁신가 짐 웨이리치는 커네이선스 개념을 대중화하며 두 가지 조언을 남김
  - **`정도의 규칙`**
    - 강한 형태의 커네이선스를 보다 약한 형태의 커네이선스로 전환하라

  - **`지역성의 규칙`**
    - 소프트웨어 엘리먼트 간의 거리가 멀어질수록 보다 약한 형태의 커네이선스를 사용하라

### 3.2.6 커플링과 커네이선스 메트릭을 통합
- 아키텍트 관점에서는 시기와 목표가 상이한 커플링과 커네이선스에 대한 뷰가 서로 중첩됨
  - 정적 커네이선스는 유출/유입 커플링 정도와 같음

- 구조적 프로그래밍은 들어오고 나가는 것에만 관심있는 반면, 커네이선스는 여러 가지 요소가 서로 어떻게 커플링되는지에 주목함

  <img width="543" height="278" alt="CleanShot 2025-08-24 at 02 52 53" src="https://github.com/user-attachments/assets/f49e64bd-e474-46f5-83db-13c4aaba34d6" />

#### 1990년대 커네이선스의 문제점
- 다만, 아키텍트가 이런 메트릭을 적용해 시스템을 분석/설계할 때에는 몇 가지 문제점이 있음
- 이러한 메트릭은 아키텍처 구조보다는 저수준 코드의 세부분을, 코드 품질 및 정리 상태 위주로 관찰함
  - 아키텍트 입장에서는 커플링 정도보다 모듈이 어떻게 커플링 되어 있는지가 더 궁금하기 마련

- 커네이선스 자체는 아키텍트가 내려야 할 근본적인 결정에 관한 문제는 다루지 않음
  - 아키텍처에서 중요한 건 트레이드오프 

## 3.3 모듈에서 컴포넌트로
- 이책에서는 연관된 코드의 묶음을 모듈이라는 일반 용어로 표현하지만, 대부분의 플랫폼은 아키텍트에게 핵심 구성 요소 중 하나인 **`컴포넌트`** 형태로 지원함
