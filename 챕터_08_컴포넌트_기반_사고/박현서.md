개발자는 여러 가지 방법으로 모듈을 물리적으로 패키징한다.

이렇게 모듈을 물리적으로 패키징한 것을 컴포넌트라고 하며, 대부분의 언어는 패키징을 지원한다.

# 1. 컴포넌트 범위

컴포넌트는 아티팩트를 한데 묶어 필요시 중첩시켜 계층화하는, 언어에 특정한 메커니즘을 제공한다.

아키텍트는 반드시 컴포넌트를 사용해야 하는 것은 아니지만 모듈성을 가지는 것이 유용할 때가 많다.

# 2. 아키텍트 역할

아키텍트는 아키텍처 내부의 컴포넌트를 정의, 개선, 관리, 통제하는 일을 한다.

일반적으로 컴포넌트는 아키텍트가 직접 맞닥뜨리는 최하위 소프트웨어 시스템이지만, 전체 코드베이스에 영향을 미치는 코드 품질 메트릭은 예외다.

**컴포넌트는 클래스나 함수로 구성되며, 이들을 설계하는 업무는 기술 리더나 개발자가 담당**한다.

**아키텍트는 클래스 설계에 참여해서도 안되고 시스템의 세세한 설계 결정에 관여해서도 안된다.**

## 1) 아키텍처 분할

최상위 분할 스타일

- 레이어드 아키텍처
    - 익숙한 형태
    - **기술적 최상위 분할은 레이어드 아키텍처와 같이 기술적인 능력에 따라 아키텍처를 구성하는 것이다.**
    - 시스템 기능을 기술적인 능력으로 프레젠테이션, 비즈니스 규칙, 서비스 ,퍼시스턴스 등으로 분할했다.
- 모듈러 모놀리스 아키텍처
    - 기술적인 능력이 아닌, 도메인에 따라 분할된 단일 배포 단위
    - 복잡한 소프트웨어 시스템을 분리하는 모델링 기법을 다룬 에릭 에반스의 “도메인 주도 설계”에서 비롯됐다.
    - **모듈러 모놀리스를 설계하는 아키텍트는 기술적인 능력 대신, 도메인이나 워크플로에 따라 아키텍처를 분할한다.**

**서로 다른 아키텍처 패턴 간의 근복적인 차이점 중의 하나가 바로 각각의 개별 패턴을 다루는 최상위 분할의 유형이다.** 아키텍트가 초기에 어떻게 컴포넌트를 식별해야 할 지 결정할 때에도 최상위 분할 유형은 매우 큰 영향을 미친다.

## 2) 분할 사례 연구: 실리콘 샌드위치

컴포넌트 도출 시 아키텍트는 기본적으로 최상위 분할을 어떻게 할지 결정해야 한다.

- 도메인 분할
    - 도메인 분할 아키텍처는 최상위 컴포넌트를 워크플로 및 도메인에 따라 나눈다.
    - 장점
        - 세부 구현보다 비즈니스 기능에 더 가깝게 모델링된다.
        - 역 콘웨이 전략을 활용하여 도메인별 다목적팀을 구성하기 쉽다.
        - 모듈러 모놀리스와 마이크로서비스 아키텍처 스타일에 더 가깝게 맞출 수 있다.
        - 메시지 흐름이 문제 영역과 일치한다.
        - 데이터와 컴포넌트를 분산 아키텍처로 옮기기 쉽다.
    - 단점
        - 유저 정의 코드가 여기저기 널려있다.
- 기술 분할
    - 기술 분할 아키텍처는 최상위 컴포넌트를 개별 워크플로가 아닌, 기술적인 능력에 따라 분리하므로 MVC 또는 상황에 맞게 기술 분할된 레이어로 나타낼 수 있다.
    - 장점
        - 커스텀 코드가 명확하게 분리된다.
        - 레이어드 아키텍처 패턴에 더 가깝게 맞출 수 있다.
    - 단점
        - 전역 커플링이 더 높다.
        - 개발자가 공통 레이어 ,로컬 레이어 양쪽에 도메인 개념을 복제해야 할 수도 있다.
        - 일반적으로 데이터 레벨의 커플링이 높다.

# 3. 개발자 역할

개발자는 아키텍트와 공동 설계한 컴포넌트를 바탕으로 클래스, 함수, 서브컴포넌트로 더 잘게 나눈다.

개발자는 아키텍트가 설계한 컴포넌트가 최종판이라고 생각해선 안된다.

모든 소프트웨어 설계는 이터레이션을 거쳐 점점 다듬어진다. 초기 설계는 일단 초안으로 보고 차후 구현을 하며 상세한 것들을 밝히고 하나씩 개선을 하면 된다.

# 4. 컴포넌트 식별 흐름

컴포넌트 식별은 후보를 도출하고 피드백을 통해 다듬어가는 과정을 반복하는 것이 가장 좋다.

## 1) 초기 컴포넌트 식별

- 소프트웨어 프로젝트의 소스 코드가 생기기 전에 적용할 최상위 분할의 유형에 따라 최상위 컴포넌트를 어디서부터 시작할지 결정해야 한다.
- 아키텍트는 원하는 컴포넌트를 자유롭게 구성하면서 어느 기능을 어디에 둘지 도메인 기능을 매핑한다.

초기 식별한 컴포넌트들만으로 제대로 된 설계가 나올 가능성은 거의 없으니 아키텍트는 컴포넌트 설계를 이터레이션하면서 조금씩 개선해야 한다.

## 2) 요구사항을 컴포넌트에 할당

- 컴포넌트에 **요구사항(또는 유저 스토리)을 대입**해서 잘 맞는지 확인한다.
- 컴포넌트를 새로 만들거나 기존 컴포너트를 통합하고, 하는 일이 너무 많은 컴포넌트는 분해할 수 있다.

## 3) 역할 및 책임 분석

- 컴포넌트에 스토리를 대입할 때 **요구사항을 파악하는 단계**에서 밝혀진 역할과 책임도 살펴보고 세분도가 적합한지 확인한다. → 애플리케이션이 지원해야 할 역할과 기능 둘 다 고려해야 컴포넌트와 도메인의 세분도를 서로 맞출 수 있다.

## 4) 아키텍처 특성 분석

- **컴포넌트에 요구사항을 대입할 때** 앞서 식별한 아키텍처 특성들이 컴포넌트 분할 및 세분도에 어떤 영향을 미치는지 살펴봐야 한다. → 순수하게 기능적인 관점에서만 컴포넌트를 설계하면 유저 상호작용을 처리하는 단일 컴포넌트가 도출되지만 아키텍처 특성들을 분석하면 더 하위 컴포넌트로 잘게 나눌 수 있다.

## 5) 컴포넌트 재구성

- 개발자들과 함께 지속적으로 컴포넌트 설계를 반복해야 한다.

# 5. 컴포넌트 세분도

컴포넌트를 너무 잘게 나누어 설계하면 컴포넌트 간 통신이 너무 많아진다.

그렇다고 너무 크게 나누면 내부적으로 커플링이 증가해서 배포, 테스트가 어려워지고 모듈성 관점에서도 부정적인 영향을 미친다.

# 6. 컴포넌트 설계

아키텍트는 아키텍처를 설계하면서 요구사항을 접수하고 애플리케이션을 구성할 굵직굵직한 구성 요소를 그려봐야 한다.

## 1) 컴포넌트 발견

아키텍트는 개발자, 비즈니스 분석가, 도메인 전문가와 협력해서 시스템에 관한 일반적인 지식과 시스템을 어떻게 분할할지 결정한다.

- **엔티티 함정**
    - 컴포넌트를 확정하는 문제에 정답은 없지만, 엔티티 함정은 조심하자.
    - **아키텍트가 데이터베이스 관계를 애플리케이션의 워크플로로 오해할 때 벌어진다.**
- **액터/액션 접근법**
    - 아키텍트가 요구사항을 컴포넌트에 매핑할 때 즐겨 쓰는 방법이다.
    - 애플리케이션에서 뭔가 일을 하는 액터와 그들이 수행하는 액션을 식별하고 시스템의 대표적인 유저와 이들이 시스템에서 어떤 종류의 일을 하는지 찾아내는 기법이다.
- **이벤트 스토밍**
    - DDD에서 사용되는 컴포넌트 발견 기법이다.
    - 이벤트 스토밍을 하는 프로젝트에서는 다양한 컴포넌트가 메시지나 이벤트를 이용해 서로 통신한다고 가정한다. 팀은 요구사항과 식별된 역할에 따라 시스템에서 어떤 이벤트가 일어나는지 파악하고 컴포넌트를 이벤트와 메시지 핸들러 중심으로 구축한다.
- **워크플로 접근법**
    - **이벤트 스토밍의 대안으로, DDD나 메시징을 사용하지 않는, 더 일반화한 방법이다.**
    - 워크플로 기반의 컴포넌트 모델링은 이벤트 스토밍과 비슷하지만 메시지 기반 시스템을 구축하는 데 있어서 명시적인 제약 조건은 없다. 워크플로 접근법은 핵심 역할을 식별하고 이 역할이 관여하는 워크플로 유형을 결정하며 그렇게 식별된 활동에 따라 컴포넌트를 구축한다.개발자는 여러 가지 방법으로 모듈을 물리적으로 패키징한다.

이렇게 모듈을 물리적으로 패키징한 것을 컴포넌트라고 하며, 대부분의 언어는 패키징을 지원한다.
