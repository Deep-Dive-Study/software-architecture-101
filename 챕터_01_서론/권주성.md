# Chapter 1 서론

## 1.1 소프트웨어 아키텍처란?
- 시스템의 청사진, 시스템 개발의 이정표
  - 다소 모호한 정의 

- 아래 그림은 소프트웨어 아키텍처를 바라보는 한가지 방법

  <img width="528" height="417" alt="CleanShot 2025-08-17 at 14 30 50" src="https://github.com/user-attachments/assets/a692ce54-bfb1-4f61-8ecc-b4acb7ce97d4" />

  - 아키텍처 특성, 아키텍처 결정, 설계 원칙, 시스템 구조 

- **`시스템의 구조`**
	- 시스템이 구현된 아키텍처 스타일의 종류(마이크로서비스, 레이어드, 모놀리식, 등)

     <img width="495" height="404" alt="CleanShot 2025-08-17 at 14 32 24" src="https://github.com/user-attachments/assets/737dd887-8abc-4e73-b64a-237ac46d66bf" />

- **`아키텍처 특성`**
  - 시스템의 기능과 직교하는 시스템의 성공 기준 (가용성, 신뢰성, 보안, 확장성 등등)
  - 시스템이 지원해야 하는  `~성` 으로 표현되는 것

    <img width="498" height="403" alt="CleanShot 2025-08-17 at 14 33 37" src="https://github.com/user-attachments/assets/648a3c2a-f123-4cfd-b406-9c5a174138dd" />

- **`아키텍처 결정`**
	- 시스템 구축에 필요한 규칙들을 정의한 것
    - 즉, 시스템의 제약조건을 형성하여, 개발자가 해도 되는 것과 하지 말아야 할 것을 알려줌
    - Ex. 레이어드 아키텍처에서 프레젠테이션 레이어가 데이터베이스에 직접 액세스하면 안된다.
	- 간혹, 어떠한 상황, 이유 때문에 이러한 원칙들을 지킬 수는 없는 경우 논의를 통해 변형할 수 있음

     <img width="498" height="398" alt="CleanShot 2025-08-17 at 14 35 00" src="https://github.com/user-attachments/assets/5de18eca-5ede-4024-b7c2-20faab480664" />

- **`설계 원칙`**
	- 아키텍처 결정이 반드시 지켜야 할 규칙이라면 설계 원칙은 가이드라인임
    - Ex. 성능 향상을 위해서 서비스 간 통신은 비동기 메시징을 활용
	- 아키텍처 결정만으로 모든 조건과 구현 방안을 다룰 수 없기 때문에 우선 권장하는 방법에 대한 가이드를 설계 원칙으로 제공함(강제X)

    <img width="498" height="397" alt="CleanShot 2025-08-17 at 14 38 18" src="https://github.com/user-attachments/assets/2da4de6a-a0b4-48f2-864c-55b8eb0689d1" />

## 1.2 아키텍트에 대한 기대치
- 소프트웨어 아키텍트는 무엇을 하는 사람인지 정의 내리기 쉽지 않음
- 따라서, 보편적으로 아키텍트에게 기대하는 바를 살펴보고자 함
- 역할, 직책, 직무 상관 없이 소프트웨어 아키텍트에게 바라는 핵심적인 요구사항은 아래와 같음
  - 아키텍처 결정을 내림
  - 아키텍처를 지속적으로 분석
  - 최신 트렌드 유지
  - 아키텍처 결정의 컴플라이언스를 보장
  - 다양한 기술과 경험에 노출됨
  - 비즈니스 도메인 지식을 보유해야함
  - 대인 관계 기술이 뛰어남
  - 정치를 이해하고 처새를 잘함

### 1.2.1 아키텍처 결정을 내린다
- 아키텍트는 아키텍처와 설계 원칙을 결정하고 팀, 부서뿐만 아니라 `회사 전체의 기술 결정을 가이드하는 사람임`
	- 다만, 아키텍트는 기술 선택을 가이드하는 사람이지 결정해주는 사람은 아님
		- Ex. 만약, 아키텍트가 React를 사용하기로 결정하는 것은 가이드가 아닌 결정 사항임
    - 더 올바른 접근법은 프론트엔드 프레임워크를 선택할 수 있는 기준(아키텍처 결정 및 설계 원칙)을 결정하고 팀에 가이드하여 팀원들 스스로 프레임워크를 결정할 수 있도록 하는 것

  - 단, 모든 경우에 기술 선택을 가이드하는 것은 바람직하지 않을 수 있음
    - 확장성, 성능 등의 아키텍처 특성을 유지하기 위해 특정 기술을 결정해야하는 경우도 있음  

  - 그러므로 각 상황에서 기술 선택을 가이드하는 것이 더 적합할지 아니면 직접 기술을 결정하는 것이 적합할지 고려해야 됨
  
### 1.2.2 아키텍처를 지속적으로 분석한다
- 아키텍트는 끊임없이 `아키텍처와 현재 기술 환경을 분석하고 이를 개선하기 위한 해결 방안을 제시`해야함
- 아키텍트는 기술 변화와 문제 영역을 종합적으로 분석하여 아키텍처의 건전성을 추구해야함
- 소프트웨어 아키텍처는 매우 빠르게 변화하는 동적인 환경이므로 예전의 아키텍처를 지속적으로 분석하고 개선하도록 노력해야 됨

### 1.2.3 최신 트렌드를 계속 따라간다
- 아키텍트는 최신 기술과 업계 트렌드를 지속적으로 따라가야함
- 아키텍트가 결정한 것들은 대개 오래 지속되고, 바꾸기도 어렵기 때문에, 핵심 트렌드를 이해하고 계속 좇아갈 수 있어야 그나마 `미래를 대비하고 올바른 결정을 내릴 수 있음`

### 1.2.4 아키텍처 결정의 컴플라이언스를 보장한다
- 아키텍트는 아키텍처 결정과 설계 원칙의 컴플라이언스를 보장해야함
- 컴플라이언스 보장이란, 아키텍트가 정의하고 문서화하여 전달한 아키텍처 결정과 설계 원칙들을 `개발팀이 제대로 준수하고 있는지 지속적으로 확인`한다는 의미

### 1.2.5 다양한 기술과 경험에 노출된다
- 아키텍트는 다양한 기술, 프레임워크, 플랫폼, 환경에 노출되어야 함
- 요즘 환경은 대부분 복합적인 경우가 많아서 어떤 언어와 플랫폼, 기술로 개발되었든지 다양한 시스템과 서비스를 연동하는 방법을 알고 있어야함
- 아키텍트는 기술의 깊이보다는 폭에 초점을 두어야함
  - `어느정도 다룰 줄 알고, 각각의 장단점을 아는게 중요`

### 1.2.6 비즈니스 도메인 지식을 보유한다
- 아키텍트는 어느정도 수준 이상의 비즈니스 도메인 전문가여야함
- 비즈니스의 문제점, 목표, 요구사항을 이해하고 있어야만 비즈니스 요구사항을 수용할 만한 효율적인 아키텍처를 설계할 수 있음
- 내부 이해관계자들과 효율적인 의사소통을 위해서는 도메인 지식과 언어를 이해하고 있어야 함(신뢰감 제공)

### 1.2.7 대인 관계 기술이 뛰어나다
- 아키텍트는 팀워크, 리더십을 포함한 대인 관계 기술이 뛰어나야 함
- 아키텍트는 개발팀을 기술적으로 이끌기만 하는 사람이 아니라, 개발팀을 리드해서 아키텍처를 구현하는 사람이므로 리더십 스킬은 매우 중요함
  - 개발도 결국 사람이 문제..
  - 여러 아키텍트 사이에서 경쟁력을 가지려면 대인 관계도 잘해야함  

### 1.2.8 정치를 이해하고 처세를 잘한다
- 아키텍트는 기업 내부의 정치적 분위기를 이해하고 적절하게 잘 처신할 줄 알아야 함
- 아키텍트가 내린 거의 모든 결정은 사람들의 반발에 부딪히기 때문에, 대부분의 결정을 사람들이 수용하도록 기본적인 협상 기술을 발휘할 줄 알아야함

## 1.3 아키텍처의 교차점 그리고...
- 소프트웨어 아키텍처의 범위는 지난 10년 동안 점점 더 많은 책임과 관점을 아우르는 방향으로 확대되었음
  - 10년 전만 해도 대부분의 회사는 자체 운영보다 서드파티 회사에 외주를 맡기는 경우가 많았고 가동 시간, 확장성, 응답성, 그 밖의 중요한 아키텍처 특성을 SLA 으로 묶어 계약 이행을 요구함

- 현재의 마이크로서비스 같은 아키텍처에서는 예전의 순전히 운영 관심사였던 부문을 자유롭게 넘나들 수 있게되었음
  - 예전에는 탄력적 확장 기능을 구현하기 까다로웠지만 현재는 아키텍트와 데브옵스 간에 소통을 하면서 마이크로서비스를 훨씬 수월하게 구현할 수 있게됨

## 1.3.1 엔지니어링 프랙티스
- 과거 소프트웨어 아키텍처는 소프트웨어를 제작하는 개발 프로세스와 분리돼 있었음
  - 소프트웨어를 구축하는 방법론(애자일, 폭포수, 등)은 아키텍처에 영향을 주지 못했음

- 지난 몇 년 동안 엔지니어링 분야가 발전을 거듭했고 소프트웨어 아키텍처의 프로세스 문제를 고민하기 시작함
  - 여기서 엔지니어링 프랙티스와 소프트웨어 개발 프로세스는 구분해야함

- 엔지니어링 프랙티스
  - 프로세스와 무관하게 가시적이고 반복 가능한 혜택을 주는 실천론 (Ex. CI/CD)

- 소프트웨어 개발 프로세스
  - 팀을 어떻게 구성하고 관리할지, 회의는 어떻게 하고 워크플로 조직은 어떻게 운영할지 등 사람을 조직하고 상호작용하는 총체적인 기법(Ex. 애자일)
  
- 엔지니어링 프랙티스에 집중하는 것이 중요함
  - 소프트웨어 개발 분야는 보다 성숙한 다른 엔지니어링 체계에 있는 많은 특성들이 빠져있음
    - Ex. 중요한 구조를 변경할 경우 토목 엔지니어는 소프트웨어 엔지니어보다 훨씬 더 정확하게 결과를 예측할 수 있음

  - 소프트웨어 개발은 추정하기 어려움(리소스, 비용, 소요 시간, 등)
    - **`알려지지 않은 미지의 것들(unknown unknowns)`** 때문에 더 어려움(소프트웨어 시스템에선 필연적)
  		- `알려진 기지의 것들(known knowns)`: 이미 알고있는 것들
  		- `알려진 미지의 것들(known unknowns)`: 모른다는 것을 알고있는 것들
  		- `알려지지 않은 미지의 것들(unknown unknowns)`: 모른다는 사실 조차 모르는 것들

  - 이 'unknown unknowns' 때문에 반복적인 프로세스가 더 잘 맞음
    - `빅 디자인 업 프런트 방식` (일단 설계부터 확실하게) 으로 진행하기 어려움
    - 폭포수 모델로 마이크로서비스 같은 현대적인 시스템을 구축하기 까다로움

- 모든 아키텍처는 알려지지 않은 미지의 것들 때문에 자꾸 되풀이되는데, 애자일은 단지 이것을 인지해서 더 빨리 수행하는 것이다.

- 아키텍트는 프로젝트 기술 리더를 겸하는 경우도 많기에 팀의 엔지니어링 프랙티스를 결정함
	- 아키텍처 스타일과 엔지니어링 프랙티스가 공생 관계망을 형성하도록 해야함
  - Ex. 마이크로 서비스 아키텍처는 머신 프로비저닝, 자동화 테스팅/배포 등 많은 것들을 전제로함
  - 아키텍처와 운영 프로세스가 맞지 않으면 많은 충돌과 난관에 봉착함. 따라서, 문제 영역마다 적합한 아키텍처 스타일이 있듯이 엔지니어링 프랙티스도 동일한 종류의 공생 관계를 맺는 것이 중요함

- 소프트웨어에서는 정적인 것은 하나도 없음
- 아키텍트가 시스템을 설계할 수 있는 있지만 그 설계는 구현과 개발 생태계의 변화를 모두 거치면서 살아남아야 함
- 그러므로 진화하는 아키텍처가 필요함
	- 시간이 지나 변경이 일어나도 아키텍처 특성을 보호하기 위해 아키텍처 피트니스 함수라는 개념을 도입하는 것이 좋음
		- 아키텍처 피트니스 함수란, 어떤 아키텍처 특성의 개관적인 완전성을 평가하느 수단(메트릭, 단위 테스트, 모니터링, 카오스 엔지니어링 등의 다양한 메커니즘)
    - Ex. 페이지 로드 시간이 중요한 아키텍처 특성이라고 할 때 각 페이지 로드 시간을 측정하는 피트니스 함수를 CI에 추가하는 것

### 1.3.2 운영/데브옵스
- 1990/2000년대에 설계된 아키텍처는 대부분 아키텍트가 운영을 마음대로 할 수 없다는 전제 하에 그러한 제약 위주로 방어적으로 구축됨
- 최근에는 아키텍처와 운영 간에 연결고리를 맺어 설계를 단순화하고, 운영자가 가장 잘 처리할 수 있는 부분은 운영에 맡기는 방식으로 변화함

### 1.3.3 프로세스
- 소프트웨어를 개발하는 개발팀의 프로세스는 소프트웨어 아키텍처의 여러 파트에 영향을 미침
	- 애자일 프로세스는 아키텍트로 하여금 반복적인 개발을 통해 의사 결정에 필요한 피드백을 더 빨리 받아볼 수 있고, 피드백에 의존하는 실험과 다른 지식에 더욱 적극적으로 참여할 수 있음

- 재구성(restructuring)은 애자일 방법론의 진면목을 볼 수 있는 아키텍처의 분야임
	- 팀은 종종 아키텍처를 어떤 패턴에서 다른 패턴으로 바꾸어야 할 필요성을 깨닫음(Ex. 모놀리식에서 마이크로서비스로 변경)
	- 애자일 방법론은 피드백 루프가 더 촘촘하므로 스트랭글러 패턴, 기능 토글 등의 기법을 조합한다면 이런 변경을 더 잘 지원함

- 모든 아키텍처는 단지 시간 문제일 뿐 반복적이기 때문에, 애자일 방법론이 잘 맞으나 필요시에는 예외를 두는 것은 필요함

### 1.3.4 데이터
- 코드와 데이터는 공생 관계여서 상대방이 없으면 무용지물임
- 그러므로 DBA는 아키텍트와 협업하여 복잡한 시스템의 데이터 아키텍처를 구축해야함
- 그러므로 데이터 및 외부 데이터 스토리지 또한 아키텍처의 중요한 관심사임

## 1.4 소프트웨어 아키텍처 법칙
#### 소프트웨어 아키텍처 제 1법칙
**`소프트웨어 아키텍처의 모든 것은 다 트레이드오프다.`**
- 만약, 아키텍트가 트레이드오프가 아닌 뭔가를 발견했다고 생각한다면, 아직 트레이드오프를 발견하지 못했다는 증거일 가능성이 높다.

#### 소프트웨어 아키텍처 제 2법칙
**`어떻게 보다 왜가 더 중요하다.`**
- 자신이 전혀 모르는 기존 시스템을 들여다보면서 아키텍처의 구조적인 작동 원리를 알아 낼 수는 있지만 왜 그런 선택을 했는지는 설명하기 힘듬
- 트레이드오프를 감안하여서 왜 그런 결정을 하는지 이해하고 판단하는 것이 중요함
